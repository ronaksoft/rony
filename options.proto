syntax = "proto2";
import "google/protobuf/descriptor.proto";
option go_package = "github.com/ronaksoft/rony";

// RestOpt is the container message for all the required and optional parameters for REST setup.
// By adding 'rony_rest' option to the method definition a REST wrapper will be generated for that
// method and that RPC handler will become accessible using REST endpoint.
message RestOpt {
    // method identifies the HTTP command: i.e. 'get', 'post', 'put', ...
    required string method = 1;
    // path identifies the path that this RPC method will be available as REST endpoint.
    required string path = 2;
    // bind_variables is a list of pair of bindings. For example if we have a path '/part1/:var1/:var2'
    // and we want to bind 'var1' to field 'fieldVar1' and bind 'var2' to field 'fieldVar2' then it will be:
    // `["var1=fieldVar1" , "var2=fieldVar2"]`
    repeated string bind_variables = 3;
    // json_encode if is set then input and output data are json encoded version of the proto messages
    optional bool json_encode = 4;
}


extend google.protobuf.ServiceOptions {
    // rony_cobra_cmd generates the boiler plate code for client stub of rpc methods, using cobra package.
    optional bool rony_cobra_cmd = 50001;
    // rony_cobra_cmd_protocol defines what protocol should client use to communicate with server.
    // POSSIBLE VALUES: "ws", "http"
    optional string rony_cobra_cmd_protocol = 50002;
    // rony_no_client if is set then no client code will be generated. This flag is for internal usage.
    // DO NOT USE IT.
    optional bool rony_no_client = 50003;
}

extend google.protobuf.MethodOptions {
    // rony_internal marks this method internal, hence only edges could execute this rpc through tunnel messages. In other words,
    // this command is not exposed to external clients connected through th gateway.
    optional bool rony_internal = 50002;
    optional RestOpt rony_rest = 50003;
}

extend google.protobuf.MessageOptions {
    // rony_aggregate marks this message as an aggregate, then 'rony_table' and 'rony_view' options become available for this
    // message.
    optional bool rony_aggregate = 50001;
    // rony_singleton marks this message as a singleton.
    // NOTE: a message could either have 'rony_aggregate' ro 'rony_singleton' options at a same time. Setting both
    // cause unpredictable results.
    optional bool rony_singleton = 50002;
    // rony_aggregate_table creates a virtual table presentation to hold instances of this message, like rows in a table
    // PRIMARY KEY FORMAT: ( (partitionKey1, partitionKey2, ...), clusteringKey1, clusteringKey2, ...)
    // NOTE: If there is only one partition key then you could safely drop the parenthesis, i.e. (pk1, ck1, ck2)
    optional string rony_aggregate_table = 50014;
    // rony_aggregate_view creates a materialized view of the aggregate based on the primary key.
    // PRIMARY KEY FORMAT: ( (partitionKey1, partitionKey2, ...), clusteringKey1, clusteringKey2, ...)
    // NOTE (1): If there is only one partition key then you could safely drop the parenthesis, i.e. (pk1, ck1, ck2)
    // NOTE (2): The primary key of the model must contains all the primary key items of the table. They don't need to
    //           follow the same order as table. for example the following is correct:
    //                  rony_aggregate_table = ((a, b), c)
    //                  rony_aggregate_view = ((c, a), d, b)
    repeated string rony_aggregate_view = 50015;

}

extend google.protobuf.FieldOptions {
    optional bool rony_index = 50001;
}
package main

import (
	"bytes"
	"fmt"
	"github.com/ronaksoft/rony/cmd/protoc-gen-gorony/helper"
	"github.com/ronaksoft/rony/cmd/protoc-gen-gorony/repo"
	"github.com/ronaksoft/rony/cmd/protoc-gen-gorony/rpc"
	"github.com/ronaksoft/rony/internal/codegen"
	"google.golang.org/protobuf/compiler/protogen"
	"path/filepath"
	"text/template"
)

var (
	pluginOpt = &codegen.PluginOptions{}
	pgo       = protogen.Options{
		ParamFunc: pluginOpt.ParamFunc,
		ImportRewriteFunc: func(path protogen.GoImportPath) protogen.GoImportPath {
			// TODO:: this is a hack for bug in Golang/Protobuf which does not support go module versions
			switch path {
			case "github.com/scylladb/gocqlx":
				return "github.com/scylladb/gocqlx/v2"
			}

			return path
		},
	}
)

func main() {
	pgo.Run(
		func(plugin *protogen.Plugin) error {
			if pluginOpt.CRC32 {
				codegen.CrcBits = 32
			}

			switch pluginOpt.ConstructorFormat {
			case codegen.StringJSON:
				return jsonStr(plugin)
			case codegen.Int64JSON:
				return jsonInt(plugin)
			}

			err := normalMode(plugin)
			if err != nil {
				return err
			}

			return nil
		},
	)
}

func normalMode(plugin *protogen.Plugin) error {
	protocVer := plugin.Request.GetCompilerVersion()
	for _, protoFile := range plugin.Files {
		if !protoFile.Generate || protoFile.Proto.GetPackage() == "google.protobuf" {
			continue
		}

		// Create the generator func
		generatedFile := plugin.NewGeneratedFile(fmt.Sprintf("%s.rony.go", protoFile.GeneratedFilenamePrefix), protoFile.GoImportPath)
		generatedFile.P("// Code generated by Rony's protoc plugin; DO NOT EDIT.")
		generatedFile.P("// ProtoC ver. v", protocVer.GetMajor(), ".", protocVer.GetMinor(), ".", protocVer.GetPatch())
		generatedFile.P("// Rony ver. ", codegen.Version)
		generatedFile.P("// Source: ", protoFile.Proto.GetName())
		generatedFile.P()

		// Generate all the helper functions
		g1 := helper.New(protoFile, generatedFile, pluginOpt)
		g1.Generate()

		// Generate rpc helper functions (Server, Client and CLI)
		g2 := rpc.New(protoFile, generatedFile)
		g2.Generate()

		// Generate Repository functionalities
		g3 := repo.New(plugin, protoFile, generatedFile)
		g3.Generate()
	}

	return nil
}

func jsonStr(plugin *protogen.Plugin) error {
	var (
		importPath protogen.GoImportPath
		filePrefix string
		cn         = map[string]uint64{}
		cs         = map[uint64]string{}
	)
	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}
		importPath = f.GoImportPath
		filePrefix = f.GeneratedFilenamePrefix
		// reset the global model and fill with the new data
		for _, mt := range f.Messages {
			constructor := codegen.CrcHash([]byte(mt.Desc.Name()))
			cn[string(mt.Desc.Name())] = constructor
			cs[constructor] = string(mt.Desc.Name())
		}
		for _, s := range f.Services {
			for _, m := range s.Methods {
				methodName := fmt.Sprintf("%s%s", s.Desc.Name(), m.Desc.Name())
				constructor := codegen.CrcHash([]byte(methodName))
				cn[methodName] = constructor
				cs[constructor] = methodName
			}
		}
	}

	t := template.Must(template.New("t1").Parse(`
	{
	    "ConstructorsByName": {
	    {{range $k,$v := .}}    "{{$k}}": "{{$v}}",
		{{end -}}
		},
		"ConstructorsByValue": {
		{{range $k,$v := .}}    "{{$v}}": "{{$k}}",
		{{end -}}
		}
	}
	`))

	out := &bytes.Buffer{}
	err := t.Execute(out, cn)
	if err != nil {
		panic(err)
	}

	gf := plugin.NewGeneratedFile(filepath.Join(filepath.Dir(filePrefix), "constructors.json"), importPath)
	_, err = gf.Write(out.Bytes())
	return err
}

func jsonInt(plugin *protogen.Plugin) error {
	var (
		importPath protogen.GoImportPath
		filePrefix string
		cn         = map[string]int64{}
		cs         = map[int64]string{}
	)
	for _, f := range plugin.Files {
		if !f.Generate {
			continue
		}
		importPath = f.GoImportPath
		filePrefix = f.GeneratedFilenamePrefix
		// reset the global model and fill with the new data
		for _, mt := range f.Messages {
			constructor := int64(codegen.CrcHash([]byte(mt.Desc.Name())))
			cn[string(mt.Desc.Name())] = constructor
			cs[constructor] = string(mt.Desc.Name())
		}
		for _, s := range f.Services {
			for _, m := range s.Methods {
				methodName := fmt.Sprintf("%s%s", s.Desc.Name(), m.Desc.Name())
				constructor := int64(codegen.CrcHash([]byte(methodName)))
				cn[methodName] = constructor
				cs[constructor] = methodName
			}
		}
	}

	t := template.Must(template.New("t1").Parse(`
	{
	    "ConstructorsByName": {
	    {{range $k,$v := .}}    "{{$k}}": "{{$v}}",
		{{end -}}
		},
		"ConstructorsByValue": {
		{{range $k,$v := .}}    "{{$v}}": "{{$k}}",
		{{end -}}
		}
	}
	`))

	out := &bytes.Buffer{}
	err := t.Execute(out, cn)
	if err != nil {
		panic(err)
	}

	gf := plugin.NewGeneratedFile(filepath.Join(filepath.Dir(filePrefix), "constructors.json"), importPath)
	_, err = gf.Write(out.Bytes())
	return err
}
